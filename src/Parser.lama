-- Parser

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun value (atr, v, loc) {
  case atr of
    Ref  -> error ("reference expected", loc)
  | Void -> Ignore (v)
  | _    -> v
  esac
}

fun void (atr, v, loc) {
  case atr of
    Void -> v
  | Val  -> error ("value expected", loc)
  | _    -> error ("reference expected", loc)
  esac
}

fun ref (atr, v, loc) {
  case atr of
    Ref  -> Ref (v)
  | Void -> Ignore (Var (v))
  | _    -> Var (v)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun par(p) {
	inbr(s("("), p, s(")"))
}

fun binopSyntax (op) {
  [syntax (pos -s[op]), fun (l, loc, r) {
                          fun (a) {
                            value (a, Binop (op, l (Val), r (Val)), loc)
                          }
                        }
  ]
}

fun binop(assoc, ops) {
	[assoc, map (binopSyntax, ops)]
}

fun binops(aops) {
	map (fun ([assoc, ops]) { binop(assoc, ops) }, aops)
}

var assignOp =  [Right,
                      {[
		        s (":="),
			fun (l, loc, r) {
                          fun (a) {
                            value (a, Assn (l (Ref), r (Val)), loc)
                          }
                        }
                      ]}
            	];
var elseBody = memo $ eta syntax (
        loc=pos kElse elseSt=exp kFi {
          fun(a) {
      	    elseSt (a)
          }
        }
      | loc=pos kElif ifSt=ifBody {
      	  fun (a) {
      	    ifSt (a)
      	  }
        }
      | loc=pos kFi {
          fun (a) {
            void (a, Skip, loc)
          }
       }
    ),
    ifBody = memo $ eta syntax (
    	loc=pos cond=exp kThen thenB=exp elseB=elseBody {
    	  fun (a) {
    	    If (cond (Val), thenB (a), elseB (a))
    	  }
    	}
    );
var primary = memo $ eta syntax (
				    par[exp]
			      | loc=pos kSkip { -- Skip
				      fun (a) {
				        void (a, Skip, loc)
				      }
		            }
			      | loc=pos kRead x=par[lident] { -- Read (x)
			          fun (a) {
				        void (a, Ignore (Read (x)), loc)
				      }
				    }
			      | loc=pos kWrite v=par[exp] { -- Write (v)
				      fun (a) {
				        void (a, Write (v (Val)), loc)
				      }
			        }
			      | loc=pos kIf body=ifBody {	-- If
				      fun (a) {
				        body (a)
				      }
				    }
			      | loc=pos kWhile cond=exp kDo x=exp kOd { -- While (cond, x)
				      fun (a) {
				        void (a, While(cond (Val), x (Void)), loc)
				      }
				    }
			      | loc=pos kFor x=exp s[","] cond=exp s[","] z=exp kDo y=exp kOd { -- x;While (cond, y;z)
				      fun (a) {
				        void (
				          a,
				          Seq (x (Void), While(cond (Val), Seq (y (Void), z (Void)))),
						  loc
						)
					  }
					}
				  | loc=pos kDo x=exp kWhile cond=exp kOd { -- DoWhile(x, cond)
					  fun (a) {
					    void (a, DoWhile(x (Void), cond (Val)), loc)
					  }
					}
				  | loc=pos x=lident { -- Var (x) / Ref(x)
                      fun(a) {
                        ref (a, x, loc)
                      }
                    }
                  | loc=pos n=decimal { -- Const (n)
                      fun (a) {
                        value (a, Const (stringInt (n)), loc)
                      }
                    }
    ),
    basic   = memo $ eta (expr (assignOp : binops({
                                  [Left, {"!!"}],
                                  [Left, {"&&"}],
                                  [Nona, {"==", "!=", "<", ">", "<=", ">="}],
                                  [Left, {"+", "-"}],
                                  [Left, {"*", "/", "%"}]
                                 }),
                                 primary)),
    exp     = memo $ eta syntax (basic | s1=basic s[";"] s2=exp {fun (a) {Seq (s1 (Void), s2 (a))}});

-- Public top-level parser
public parse = syntax (s=exp {s (Void)});
